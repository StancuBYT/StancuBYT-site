function renderPriceChart(samples) {
  const canvas = document.getElementById("priceChart");
  if (!canvas) return;
  if (typeof Chart === "undefined") { console.warn("Chart.js not loaded yet"); return; }
  const ctx = canvas.getContext("2d");
  try {
  try { destroyChart(); } catch(e){ console.warn("destroyChart failed", e); }
if (currentMode === "candles") {
    const { labels, ohlc } = buildCandlesSeries(samples, currentPeriod);
    priceChart = new Chart(ctx, {
      type: "candlestick",
      data: { labels, datasets: [{ label: "SBYT", data: ohlc }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true } },
          y: { beginAtZero: false }
        }
      }
    });
  } else {
    const { labels, values } = buildLineSeries(samples, currentPeriod);
    priceChart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets: [{ label: "SBYT", data: values, tension: 0.25, pointRadius: 0 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true } },
          y: { beginAtZero: false }
        }
      }
    });
  }
  } catch (e) { console.error("renderPriceChart failed", e); }
}
function updateMarketCap() {
  const el = document.getElementById("marketCap");
  if (!el) return;

  if (CURRENT_PRICE_USD == null || CURRENT_SUPPLY == null || !Number.isFinite(CURRENT_PRICE_USD) || !Number.isFinite(CURRENT_SUPPLY)) {
    el.textContent = "—";
    return;
  }

  const mc = CURRENT_PRICE_USD * CURRENT_SUPPLY;
  el.textContent = mc.toLocaleString("ro-RO", { minimumFractionDigits: 0, maximumFractionDigits: 0 });
}

async function updateSBYTPrice() {
  const priceEl = document.getElementById("sbyt-price");
  if (!priceEl) return;

  try {
    const res = await fetch(SBYT_PRICE_ENDPOINT + "?t=" + Date.now(), { cache: "no-store" });
    const data = await res.json();

    if (data && data.ok && data.priceUsd !== undefined) {
      const p = Number(data.priceUsd);
      if (Number.isFinite(p)) {
        priceEl.innerText = "$" + p.toFixed(8);

        CURRENT_PRICE_USD = p;
        updateMarketCap();

        const samples = addSample(p);
        renderPriceChart(samples);
        return;
      }
    }
    priceEl.innerText = "—";
  } catch {
    priceEl.innerText = "—";
  }
}

async function updateHolders() {
  const el = document.getElementById("holdersCount");
  if (!el) return;
  try {
    const r = await fetch(HOLDERS_ENDPOINT + "?t=" + Date.now(), { cache: "no-store" });
    const d = await r.json();
    if (d && d.ok && d.holders != null) el.textContent = Number(d.holders).toLocaleString("ro-RO");
    else el.textContent = "0";
  } catch {
    el.textContent = "0";
  }
}

async function updateTotalSupply() {
  const el = document.getElementById("totalSupply");
  if (!el) return;
  try {
    const r = await fetch(TOTALSUPPLY_ENDPOINT + "?t=" + Date.now(), { cache: "no-store" });
    const d = await r.json();
    if (d && d.ok && d.supply != null) {
      const supplyNum = Number(d.supply);
      el.textContent = supplyNum.toLocaleString("ro-RO");

      CURRENT_SUPPLY = supplyNum;
      updateMarketCap();
    } else {
      el.textContent = "—";
      CURRENT_SUPPLY = null;
      updateMarketCap();
    }
  } catch {
    el.textContent = "—";
    CURRENT_SUPPLY = null;
    updateMarketCap();
  }
}

async function updateTransactions() {
  const el = document.getElementById("transactionsCount");
  if (!el) return;
  try {
    const r = await fetch(TX_ENDPOINT + "?t=" + Date.now(), { cache: "no-store" });
    const d = await r.json();
    if (d && d.ok && d.txCount != null) el.textContent = Number(d.txCount).toLocaleString("ro-RO");
    else el.textContent = "0";
  } catch {
    el.textContent = "0";
  }
}

async function updateContractInfo() {
  const creationEl = document.getElementById("creationDate");
  const ageEl = document.getElementById("contractAge");
  try {
    const r = await fetch(CONTRACT_INFO_ENDPOINT + "?t=" + Date.now(), { cache: "no-store" });
    const d = await r.json();
    if (d && d.ok && d.createdAt) {
      const date = new Date(d.createdAt);
      if (creationEl) creationEl.textContent = date.toLocaleDateString("ro-RO");
      if (ageEl && typeof d.ageDays === "number") ageEl.textContent = d.ageDays.toLocaleString("ro-RO");
      return;
    }
  } catch {}
  // fallback: don't overwrite if already set
}

function syncActiveButtons() {
  document.querySelectorAll(".period-btn").forEach(btn => {
    const oc = (btn.getAttribute("onclick") || "").replace(/\s+/g, "");
    if (oc.includes("changeChartPeriod")) {
      const isActive = oc.includes(`'${currentPeriod}'`) || oc.includes(`\"${currentPeriod}\"`);
      btn.classList.toggle("active", isActive);
    }
    if (oc.includes("changeChartType")) {
      if (oc.includes("candlestick") || oc.includes("candles")) btn.classList.toggle("active", currentMode === "candles");
      if (oc.includes("line")) btn.classList.toggle("active", currentMode === "line");
    }
  });
}

window.changeChartPeriod = function(period) {
  currentPeriod = period;
  syncActiveButtons();
  renderPriceChart(loadSamples());
};

window.changeChartType = function(mode) {
  currentMode = (mode === "candlestick" || mode === "candles") ? "candles" : "line";
  syncActiveButtons();
  renderPriceChart(loadSamples());
};

window.fetchAllData = function() {
  updateSBYTPrice();
  updateHolders();
  updateTotalSupply();
  updateTransactions();
  updateContractInfo();
};

document.addEventListener("DOMContentLoaded", () => {
  // Load non-chart metrics first (so a chart error can't block them)
  updateHolders();
  updateTotalSupply();
  updateTransactions();
  updateContractInfo();
  updateSBYTPrice();

  // Chart init from cached samples (guarded)
  try { syncActiveButtons(); } catch(e) { console.warn("syncActiveButtons failed", e); }
  try { renderPriceChart(loadSamples()); } catch(e) { console.warn("initial chart render failed", e); }

  setInterval(updateSBYTPrice, 30000);
  setInterval(updateHolders, 300000);
  setInterval(updateTotalSupply, 300000);
  setInterval(updateTransactions, 300000);
  setInterval(updateContractInfo, 3600000);
});
</script>


</body>
</html>
