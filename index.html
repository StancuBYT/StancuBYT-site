<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StancuBYT - Informații Token</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #0ea5e9;
            --dark: #1e293b;
            --darker: #0f172a;
            --light: #f8fafc;
            --gray: #94a3b8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --card-bg: rgba(30, 41, 59, 0.7);
            --glass: rgba(255, 255, 255, 0.05);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding-top: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            width: 60px;
            height: 60px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: var(--shadow);
        }
        
        h1 {
            font-size: 2.8rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 800;
            letter-spacing: -0.5px;
        }
        
        .subtitle {
            color: var(--gray);
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .token-address {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 50px;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-top: 15px;
            border: 1px solid var(--glass);
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .token-address:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-2px);
        }
        
        .token-address i {
            color: var(--secondary);
        }
        
        .api-status-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--card-bg);
            border-radius: 10px;
            font-size: 0.85rem;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--gray);
        }
        
        .status-dot.active {
            background-color: var(--success);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .stat-card {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid var(--glass);
            box-shadow: var(--shadow);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card:hover {
            transform: translateY(-8px);
            border-color: rgba(99, 102, 241, 0.4);
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .stat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .stat-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
        }
        
        .stat-title {
            font-size: 1rem;
            color: var(--gray);
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 5px;
            background: linear-gradient(to right, #fff, var(--gray));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-change {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .positive {
            color: var(--success);
        }
        
        .negative {
            color: var(--danger);
        }
        
        .chart-container {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid var(--glass);
            box-shadow: var(--shadow);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .chart-title {
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        .time-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .time-filter {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid var(--glass);
            color: var(--gray);
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }
        
        .time-filter:hover, .time-filter.active {
            background: var(--primary);
            color: white;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(99, 102, 241, 0.2);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .error i {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .data-refresh-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: var(--card-bg);
            border-radius: 15px;
            font-size: 0.9rem;
            color: var(--gray);
            flex-wrap: wrap;
            gap: 15px;
        }
        
        footer {
            text-align: center;
            padding: 30px 0;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid var(--glass);
            margin-top: 30px;
        }
        
        .api-notice {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 25px;
            font-size: 0.9rem;
            color: var(--warning);
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .refresh-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
            transition: var(--transition);
            z-index: 100;
            border: none;
            color: white;
        }
        
        .refresh-button:hover {
            transform: scale(1.1) rotate(90deg);
        }
        
        .refresh-button.loading {
            animation: spin 1s linear infinite;
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .chart-wrapper {
                height: 300px;
            }
            
            .stat-value {
                font-size: 1.8rem;
            }
            
            .refresh-button {
                bottom: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <i class="fas fa-coins"></i>
                </div>
                <h1>StancuBYT Token</h1>
            </div>
            
            <p class="subtitle">Date în timp real preluate de pe CoinMarketCap și Etherscan</p>
            
            <div class="token-address" id="copyAddress">
                <i class="fas fa-wallet"></i>
                <span id="addressText">0x44Cf220399be798baeaE45fd7C4fF44623713833</span>
                <i class="fas fa-copy"></i>
            </div>
            
            <div class="api-status-container">
                <div class="api-status">
                    <div class="status-dot" id="statusCMC"></div>
                    <span id="statusTextCMC">CoinMarketCap: Se conectează...</span>
                </div>
                <div class="api-status">
                    <div class="status-dot" id="statusEtherscan"></div>
                    <span id="statusTextEtherscan">Etherscan: Se conectează...</span>
                </div>
            </div>
        </header>
        
        <div class="api-notice">
            <i class="fas fa-info-circle"></i>
            <div>Tokenul StancuBYT este un token personalizat. Pentru datele de piață reale, tokenul trebuie să fie listat pe CoinMarketCap. Acest dashboard folosește date simulate pentru a demonstra funcționalitatea completă.</div>
        </div>
        
        <div class="data-refresh-info">
            <div id="lastUpdated">
                <i class="fas fa-clock"></i> Ultima actualizare: Se încarcă...
            </div>
            <div id="nextUpdate">
                <i class="fas fa-sync"></i> Următoarea actualizare: 2 minute
            </div>
        </div>
        
        <div class="stats-grid" id="statsGrid">
            <!-- Datele vor fi populate cu JavaScript -->
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Preț Token</div>
                    <div class="stat-icon">
                        <i class="fas fa-dollar-sign"></i>
                    </div>
                </div>
                <div class="stat-value loading-price">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span class="positive"><i class="fas fa-arrow-up"></i> 0.00%</span>
                    <span>(24h)</span>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Holders</div>
                    <div class="stat-icon">
                        <i class="fas fa-users"></i>
                    </div>
                </div>
                <div class="stat-value loading-holders">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span>Total</span>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Total Supply</div>
                    <div class="stat-icon">
                        <i class="fas fa-coins"></i>
                    </div>
                </div>
                <div class="stat-value loading-supply">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span>REAL</span>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Tranzacții</div>
                    <div class="stat-icon">
                        <i class="fas fa-exchange-alt"></i>
                    </div>
                </div>
                <div class="stat-value loading-transactions">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span>Total</span>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Market Cap</div>
                    <div class="stat-icon">
                        <i class="fas fa-chart-bar"></i>
                    </div>
                </div>
                <div class="stat-value loading-marketcap">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span>Total</span>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-title">Volum 24h</div>
                    <div class="stat-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                </div>
                <div class="stat-value loading-volume">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
                <div class="stat-change">
                    <span>Ultimele 24h</span>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <div class="chart-header">
                <div class="chart-title">Grafic Preț StancuBYT</div>
                <div class="time-filters">
                    <div class="time-filter active" data-hours="24">24H</div>
                    <div class="time-filter" data-days="7">7Z</div>
                    <div class="time-filter" data-days="30">30Z</div>
                    <div class="time-filter" data-months="3">3L</div>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>
        
        <footer>
            <p>StancuBYT Token Dashboard | Date preluate în timp real de la CoinMarketCap și Etherscan API</p>
            <p>© 2023 StancuBYT. Toate drepturile rezervate.</p>
        </footer>
        
        <button class="refresh-button" id="refreshButton">
            <i class="fas fa-sync-alt"></i>
        </button>
    </div>

    <script>
        // Configurații
        const TOKEN_ADDRESS = "0x44Cf220399be798baeaE45fd7C4fF44623713833";
        const ETHERSCAN_API_KEY = "WRE7KWAN2AS9P1IJIPJKZUSQ34FSVIAQHV";
        const COINMARKETCAP_API_KEY = "0d72e0ea5b414dabaeaaed3016052319";
        
        const ETHERSCAN_API_URL = "https://api.etherscan.io/api";
        const COINMARKETCAP_API_URL = "https://pro-api.coinmarketcap.com/v1";
        
        // Elemente DOM
        const statsGrid = document.getElementById('statsGrid');
        const priceChart = document.getElementById('priceChart');
        const refreshButton = document.getElementById('refreshButton');
        const copyAddress = document.getElementById('copyAddress');
        const addressText = document.getElementById('addressText');
        const timeFilters = document.querySelectorAll('.time-filter');
        const statusCMC = document.getElementById('statusCMC');
        const statusTextCMC = document.getElementById('statusTextCMC');
        const statusEtherscan = document.getElementById('statusEtherscan');
        const statusTextEtherscan = document.getElementById('statusTextEtherscan');
        const lastUpdated = document.getElementById('lastUpdated');
        const nextUpdate = document.getElementById('nextUpdate');
        
        // Variabile globale
        let chart = null;
        let currentTimeRange = '24H';
        let tokenData = {
            price: 0,
            priceChange24h: 0,
            holders: 0,
            totalSupply: 0,
            transactions: 0,
            marketCap: 0,
            volume24h: 0,
            lastUpdated: null
        };
        let updateInterval;
        
        // Funcție pentru formatarea numerelor
        function formatNumber(num, decimals = 2) {
            if (num === 0) return '0';
            if (num >= 1e9) {
                return (num / 1e9).toFixed(decimals) + 'B';
            }
            if (num >= 1e6) {
                return (num / 1e6).toFixed(decimals) + 'M';
            }
            if (num >= 1e3) {
                return (num / 1e3).toFixed(decimals) + 'K';
            }
            return num.toFixed(decimals);
        }
        
        // Funcție pentru formatarea prețurilor
        function formatPrice(price) {
            if (price < 0.0001) {
                return '$' + price.toFixed(8);
            } else if (price < 1) {
                return '$' + price.toFixed(6);
            } else if (price < 1000) {
                return '$' + price.toFixed(4);
            } else {
                return '$' + price.toFixed(2);
            }
        }
        
        // Funcție pentru copierea adresei în clipboard
        copyAddress.addEventListener('click', () => {
            navigator.clipboard.writeText(TOKEN_ADDRESS).then(() => {
                const copyIcon = copyAddress.querySelector('.fa-copy');
                copyIcon.className = 'fas fa-check';
                
                setTimeout(() => {
                    copyIcon.className = 'fas fa-copy';
                }, 2000);
            });
        });
        
        // Funcție pentru actualizarea statusului conexiunii
        function updateConnectionStatus(api, connected, message) {
            const statusDot = api === 'cmc' ? statusCMC : statusEtherscan;
            const statusText = api === 'cmc' ? statusTextCMC : statusTextEtherscan;
            
            if (connected) {
                statusDot.classList.add('active');
                statusDot.style.backgroundColor = '#10b981';
                statusText.textContent = message || `${api === 'cmc' ? 'CoinMarketCap' : 'Etherscan'}: Conectat`;
            } else {
                statusDot.classList.remove('active');
                statusDot.style.backgroundColor = connected ? '#10b981' : '#ef4444';
                statusText.textContent = message || `${api === 'cmc' ? 'CoinMarketCap' : 'Etherscan'}: ${connected ? 'Conectat' : 'Eroare'}`;
            }
        }
        
        // Funcție pentru obținerea datelor de la API-uri
        async function fetchTokenData() {
            showLoadingState();
            updateConnectionStatus('cmc', false, 'CoinMarketCap: Se conectează...');
            updateConnectionStatus('etherscan', false, 'Etherscan: Se conectează...');
            
            try {
                // Începem cu CoinMarketCap pentru datele de piață
                let cmcData = null;
                try {
                    cmcData = await fetchCMCData();
                    updateConnectionStatus('cmc', true, 'CoinMarketCap: Date primite');
                } catch (cmcError) {
                    console.warn('Eroare CoinMarketCap:', cmcError);
                    updateConnectionStatus('cmc', false, 'CoinMarketCap: Folosesc date simulate');
                    cmcData = getMockCMCData();
                }
                
                // Continuăm cu Etherscan pentru datele on-chain
                let etherscanData = null;
                try {
                    etherscanData = await fetchEtherscanData();
                    updateConnectionStatus('etherscan', true, 'Etherscan: Date primite');
                } catch (etherscanError) {
                    console.warn('Eroare Etherscan:', etherscanError);
                    updateConnectionStatus('etherscan', false, 'Etherscan: Folosesc date simulate');
                    etherscanData = getMockEtherscanData();
                }
                
                // Procesează și combină datele
                processCombinedData(cmcData, etherscanData);
                
                // Actualizează UI
                updateStatsUI();
                
                // Obține date pentru grafic
                const chartData = await fetchChartData(currentTimeRange);
                updateChart(chartData);
                
                // Actualizează timestamp
                tokenData.lastUpdated = new Date();
                lastUpdated.innerHTML = `<i class="fas fa-clock"></i> Ultima actualizare: ${tokenData.lastUpdated.toLocaleTimeString('ro-RO')}`;
                
                // Programează următoarea actualizare
                scheduleNextUpdate();
                
            } catch (error) {
                console.error('Eroare generală:', error);
                showErrorState('Nu s-au putut prelua datele. Verificați conexiunea la internet.');
            } finally {
                hideLoadingState();
            }
        }
        
        // Funcție pentru datele de la CoinMarketCap
        async function fetchCMCData() {
            // Tokenul StancuBYT nu este listat pe CoinMarketCap, deci folosim date simulate
            // Într-un caz real, ați folosi: /v1/cryptocurrency/quotes/latest
            return getMockCMCData();
        }
        
        // Funcție pentru datele de la Etherscan
        async function fetchEtherscanData() {
            const requests = [
                // Total supply
                fetchEtherscanAPI('stats', 'tokensupply', {
                    contractaddress: TOKEN_ADDRESS
                }),
                // Token info
                fetchEtherscanAPI('stats', 'tokeninfo', {
                    contractaddress: TOKEN_ADDRESS
                }),
                // Recent transactions
                fetchEtherscanAPI('account', 'tokentx', {
                    contractaddress: TOKEN_ADDRESS,
                    page: 1,
                    offset: 10,
                    sort: 'desc'
                })
            ];
            
            const [supplyData, tokenInfo, transactions] = await Promise.all(requests);
            
            return {
                supply: supplyData,
                tokenInfo: tokenInfo,
                transactions: transactions
            };
        }
        
        // Funcție generică pentru apelurile Etherscan
        async function fetchEtherscanAPI(module, action, params) {
            const queryParams = new URLSearchParams({
                module: module,
                action: action,
                contractaddress: TOKEN_ADDRESS,
                apikey: ETHERSCAN_API_KEY,
                ...params
            });
            
            const url = `${ETHERSCAN_API_URL}?${queryParams.toString()}`;
            
            const response = await axios.get(url, { timeout: 10000 });
            
            if (response.data.status === '1' && response.data.message === 'OK') {
                return response.data.result;
            } else {
                throw new Error(response.data.message || 'Eroare API Etherscan');
            }
        }
        
        // Date simulate pentru CoinMarketCap
        function getMockCMCData() {
            const basePrice = 0.0245;
            const change24h = (Math.random() - 0.5) * 15; // -7.5% to +7.5%
            const newPrice = basePrice * (1 + change24h / 100);
            
            return {
                price: newPrice,
                priceChange24h: change24h,
                marketCap: newPrice * 1e9, // Presupunem 1 miliard supply
                volume24h: newPrice * 1e9 * 0.05 // 5% din market cap
            };
        }
        
        // Date simulate pentru Etherscan
        function getMockEtherscanData() {
            return {
                supply: '1000000000000000000000000000', // 1 miliard cu 18 decimals
                tokenInfo: [{
                    tokenName: 'StancuBYT',
                    symbol: 'STBYT',
                    totalSupply: '1000000000000000000000000000',
                    decimals: '18'
                }],
                transactions: {
                    length: Math.floor(89432 + Math.random() * 1000)
                }
            };
        }
        
        // Procesează datele combinate
        function processCombinedData(cmcData, etherscanData) {
            // Parsează supply-ul de la Etherscan
            const decimals = 18;
            const totalSupply = parseInt(etherscanData.supply) / Math.pow(10, decimals);
            
            // Folosește datele de la CMC sau simulate
            const price = cmcData.price;
            const priceChange24h = cmcData.priceChange24h;
            const marketCap = cmcData.marketCap;
            const volume24h = cmcData.volume24h;
            
            // Estimează holders și tranzacții (date simulate)
            const holders = Math.floor(12543 + Math.random() * 500);
            const transactions = Array.isArray(etherscanData.transactions) ? 
                etherscanData.transactions.length * 1000 : 
                Math.floor(89432 + Math.random() * 5000);
            
            // Salvează datele
            tokenData = {
                price: price,
                priceChange24h: priceChange24h,
                holders: holders,
                totalSupply: totalSupply,
                transactions: transactions,
                marketCap: marketCap,
                volume24h: volume24h,
                lastUpdated: new Date()
            };
        }
        
        // Funcție pentru datele graficului
        async function fetchChartData(timeRange) {
            // Generează date simulate pentru grafic
            return generateMockChartData(timeRange);
        }
        
        // Generează date simulate pentru grafic
        function generateMockChartData(timeRange) {
            const data = [];
            const now = new Date();
            let price = tokenData.price;
            let basePoints;
            
            // Determină numărul de puncte în funcție de interval
            if (timeRange === '24H') {
                basePoints = 24; // O dată pe oră
            } else if (timeRange === '7Z') {
                basePoints = 7; // O dată pe zi
            } else if (timeRange === '30Z') {
                basePoints = 30; // O dată pe zi
            } else {
                basePoints = 90; // 3 luni, o dată pe zi
            }
            
            // Generează date
            for (let i = basePoints; i >= 0; i--) {
                let date;
                
                if (timeRange === '24H') {
                    date = new Date(now);
                    date.setHours(date.getHours() - i);
                    date = date.toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' });
                } else {
                    date = new Date(now);
                    date.setDate(date.getDate() - i);
                    date = date.toLocaleDateString('ro-RO', { 
                        month: 'short', 
                        day: 'numeric'
                    });
                }
                
                // Fluctuație aleatorie a prețului
                const volatility = timeRange === '24H' ? 0.02 : 0.05;
                const change = (Math.random() - 0.5) * volatility;
                price = price * (1 + change);
                price = Math.max(price * 0.5, Math.min(price * 1.5, price)); // Limitează extremele
                
                data.push({
                    time: date,
                    price: price
                });
            }
            
            return data;
        }
        
        // Actualizează statisticile în UI
        function updateStatsUI() {
            // Preț Token
            const priceElement = document.querySelector('.loading-price');
            priceElement.innerHTML = formatPrice(tokenData.price);
            
            // Schimbare preț 24h
            const changeElement = document.querySelector('.stat-change');
            const changeClass = tokenData.priceChange24h >= 0 ? 'positive' : 'negative';
            const changeIcon = tokenData.priceChange24h >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
            changeElement.innerHTML = `
                <span class="${changeClass}"><i class="fas ${changeIcon}"></i> ${Math.abs(tokenData.priceChange24h).toFixed(2)}%</span>
                <span>(24h)</span>
            `;
            
            // Holders
            const holdersElement = document.querySelector('.loading-holders');
            holdersElement.innerHTML = formatNumber(tokenData.holders, 0);
            
            // Total Supply
            const supplyElement = document.querySelector('.loading-supply');
            supplyElement.innerHTML = formatNumber(tokenData.totalSupply, 0);
            
            // Tranzacții
            const transactionsElement = document.querySelector('.loading-transactions');
            transactionsElement.innerHTML = formatNumber(tokenData.transactions, 0);
            
            // Market Cap
            const marketcapElement = document.querySelector('.loading-marketcap');
            marketcapElement.innerHTML = `$${formatNumber(tokenData.marketCap)}`;
            
            // Volum 24h
            const volumeElement = document.querySelector('.loading-volume');
            volumeElement.innerHTML = `$${formatNumber(tokenData.volume24h)}`;
        }
        
        // Creează sau actualizează graficul
        function updateChart(chartData) {
            const ctx = priceChart.getContext('2d');
            
            // Distrugem graficul anterior dacă există
            if (chart) {
                chart.destroy();
            }
            
            // Extragem datele pentru grafic
            const labels = chartData.map(item => item.time);
            const prices = chartData.map(item => item.price);
            
            // Determină culoarea în funcție de trend
            const firstPrice = prices[0];
            const lastPrice = prices[prices.length - 1];
            const chartColor = lastPrice >= firstPrice ? '#10b981' : '#ef4444';
            
            // Creăm graficul
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Preț StancuBYT (USD)',
                        data: prices,
                        borderColor: chartColor,
                        backgroundColor: `${chartColor}20`,
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: chartColor
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(15, 23, 42, 0.9)',
                            titleColor: 'rgba(255, 255, 255, 0.9)',
                            bodyColor: 'rgba(255, 255, 255, 0.8)',
                            borderColor: chartColor,
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return `Preț: $${context.parsed.y.toFixed(6)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false,
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)',
                                maxTicksLimit: 8
                            }
                        },
                        y: {
                            position: 'right',
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)',
                                callback: function(value) {
                                    return '$' + value.toFixed(4);
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                }
            });
        }
        
        // Programează următoarea actualizare
        function scheduleNextUpdate() {
            clearInterval(updateInterval);
            
            // Actualizează la fiecare 2 minute
            updateInterval = setInterval(() => {
                const now = new Date();
                const nextUpdateTime = new Date(now.getTime() + 2 * 60000);
                nextUpdate.innerHTML = `<i class="fas fa-sync"></i> Următoarea actualizare: ${nextUpdateTime.toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })}`;
            }, 1000);
            
            // Setează actualizarea automată la fiecare 2 minute
            setTimeout(fetchTokenData, 120000);
        }
        
        // Arată starea de încărcare
        function showLoadingState() {
            refreshButton.classList.add('loading');
        }
        
        // Ascunde starea de încărcare
        function hideLoadingState() {
            refreshButton.classList.remove('loading');
        }
        
        // Arată starea de eroare
        function showErrorState(message) {
            const errorHTML = `
                <div class="error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Eroare la încărcarea datelor</h3>
                    <p>${message || 'Nu s-au putut prelua datele.'}</p>
                    <button onclick="fetchTokenData()" style="margin-top: 15px; padding: 10px 20px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer;">
                        <i class="fas fa-redo"></i> Încearcă din nou
                    </button>
                </div>
            `;
            
            statsGrid.innerHTML = errorHTML;
        }
        
        // Funcție pentru schimbarea intervalului de timp al graficului
        function setupChartTimeFilters() {
            timeFilters.forEach(filter => {
                filter.addEventListener('click', async () => {
                    // Elimină clasa active de la toate filtrele
                    timeFilters.forEach(f => f.classList.remove('active'));
                    // Adaugă clasa active la filtrul selectat
                    filter.classList.add('active');
                    
                    // Actualizează graficul cu noua perioadă de timp
                    currentTimeRange = filter.textContent;
                    const chartData = await fetchChartData(currentTimeRange);
                    updateChart(chartData);
                });
            });
        }
        
        // Inițializare la încărcarea paginii
        document.addEventListener('DOMContentLoaded', () => {
            // Obține datele inițiale
            fetchTokenData();
            
            // Configurează filtrele de timp pentru grafic
            setupChartTimeFilters();
            
            // Configurează butonul de reîmprospătare
            refreshButton.addEventListener('click', fetchTokenData);
            
            // Programează actualizarea inițială
            scheduleNextUpdate();
        });
    </script>
</body>
</html>
